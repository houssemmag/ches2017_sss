\documentclass{llncs}
\pagestyle{plain}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{amsmath,amssymb}
\usepackage{tabularx}
\usepackage{algorithm}
\usepackage{algpseudocode} 
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
\usepackage{moreverb}
\usepackage[dvipsnames,table]{xcolor}

\include{macros}

\title{Enhancement of Shamir's Secret Sharing Schemes against Side-Channel Attacks}

\author{Anonymous submission to CHES'2017}
\institute{}

%\author{Houssem MAGHREBI, Emmanuel Prouff}
%\institute{
%SAFRAN Identity & Security, 
%\newline
%18, Chauss\'{e}e Jules C\'{e}sar, 95520 Osny, France.
%\newline
%\email{firstname.lastname@morpho.com}
%}

\begin{document}
\maketitle
\begin{abstract}
 \todo{}
\end{abstract}
{\bf Keywords:} Shamir's secret sharing, repairing codes, masking countermeasures, template attack, side channel attacks.
 

\section{Introduction}
\label{sec-intro}

\subsubsection{Side-Channel Attacks.}
 \todo{}
\subsubsection{Side-Channel Countermeasures.} 
 \todo{}
\subsubsection{Shamir's Secret Sharing based Countermeasures.}

In a seminal paper\,\cite{Sha79}, Shamir proposed to split a secret $A\in \GFn$ into $\nbShares$ shares such that
no tuple of shares with cardinality lower than a so-called {\em threshold} $\order<\nbShares$ depends on $A$. Shamir's
protocol consists in associating $A$ with a random polynomial $P_A(X)\doteq A + \sum_{i=1}^{\order}\polyCoef X^i$ of degree lower than $\order$ and with constant term $A=P_A(0)$. Then, the polynomial $P_A(X)$ is evaluated in $\nbShares$ distinct public non-zero elements $\pubElt[0], \ldots, \pubElt[n-1]$ in $\GFn$ to define a so-called {\em $(\nbShares,\order)$-sharing} $(A_0,A_1,\cdots,A_{\nbShares-1})$ of $A$ such that $(A_i)_{i\leqslant \nbShares}=(P_A(\alpha_i))_{i\leqslant \nbShares}$. To re-construct $A$ from its sharing, polynomial interpolation is first applied to re-construct the polynomial from its $\nbShares$ evaluations $A_i$ and then, it is evaluated in $0$. Actually, using Lagrange's
interpolation formula, the two steps can be combined in a single one thanks to the equality $ A=\sum_{i=0}^{\nbShares-1} A_i \cdot \beta_i\enspace$,  where the (public) constants $\beta_i$ are defined as $\beta_i:=\prod_{k=0,k\neq i}^{\nbShares-1} \frac{\alpha_k}{\alpha_i+\alpha_k}$. As initially observed by McEliece and Sarwate in \cite{MS81}, the sharing of $A$ described above may be viewed as an {\em encoding} with a Reed-Solomon code of parameters $[\nbShares + 1,\order + 1]$:
$$
(A,A_1,\cdots,A_{\nbShares}) = (A,\polyCoef[1],\cdots,\polyCoef[\order])\times 
\left(\begin{matrix}
1 & 1 & \hdots & 1 \\
0 & \pubElt[1] & \hdots & \pubElt[\nbShares] \\
0 & \pubElt[1]^2 & \hdots & \pubElt[\nbShares]^2 \\
\vdots & \vdots & \hdots & \vdots \\
0 & \pubElt[1]^{\order} & \hdots & \pubElt[\nbShares]^{\order} 
\end{matrix}
\right)
$$
The reconstruction of $A$ then corresponds to a simple {\em decoding}.
\vspace{3mm}

To define a $\order$\myth-order masking scheme for a block cipher
implementation where each intermediate result is split with Shamir's
technique, one must specify a secure method for the processing of field
multiplications over $\GFn$. Most of (if not all) existing protocols start from a multiplication scheme introduced by
Ben-Or \etal in the context of the Multy-Party Computation Theory
\cite{BGW88}. For this protocol to work, the number of shares $\nbShares$ per variable must be at least $2\order+1$ and for $\nbShares=2\order+1$, it is proved that it satisfies a security property encompassing the $\order$\myth-order SCA security \cite{PR11}. We give hereafter the adaptation of
\cite{BGW88} in the 
SCA context as proposed in \cite{PR11,RP12}\footnote{The protocol is 
an improved version of the protocol originally proposed by Ben-Or \etal \cite{BGW88},
due to Gennaro \etal in \cite{GRR98}.}.


\begin{algorithm}
\caption{Secure Multiplication For Shamir's Secret Sharing}
\label{alg:secmult}
\begin{algorithmic}[1]
\Require {two integers $\nbShares$ and $\order$ such that $n\geq 2d+1$, the  $(\nbShares,\order)$-sharings $(A_i)_i=(P_A(\pubElt))_i$ and $(B_i)_i=(P_{B}(\pubElt))_i$ of $A$ and $B$ respectively.}
\Require   {the $\nbShares$ distinct points $\pubElt$, the interpolation values $(\beta_0,\cdots,\beta_{\nbShares-1})$}
\Ensure     {the $(\nbShares,\order)$-sharing $(P_{C}(\alpha_i))_i$ of $C=A\cdot B$. }
\For{$i=1$ \textbf{to} $\nbShares$}
\State $W_i \leftarrow P_A(\pubElt)\cdot P_{B}(\pubElt)$

\Comment{Compute a sharing $(Q_i(\alpha_j))_{j\leq d}$ of $W_i$ with $Q_i (X) = W_i + \sum_{j=1}^{\order} a_j\cdot X^j$}
\For{$j=1$ \textbf{to} $\order$}
\State $a_j \leftarrow \texttt{rand}(\GFn)$
\EndFor
\For{$j=1$ \textbf{to} $\nbShares$}
\State $Q_i(\pubElt[j]) \leftarrow W_i +
      \sum_{k=1}^{\order} a_k\cdot \pubElt[j]^k$ \label{step:reshare} 
\EndFor  	
\EndFor
   	
\Comment{Compute the share $C_i = P_{C}(\pubElt)$ for $C=A \cdot B$}
\For{$i=1$ \textbf{to} $\nbShares$}
\State $C_i \leftarrow \sum_{j=1}^{\nbShares} Q_j(\pubElt) \cdot \beta_j$
\EndFor
\Return $(C_i)_i$
\end{algorithmic}
\end{algorithm}



The completeness of Algorithm \ref{alg:secmult} is discussed in \cite{BGW88}. Its $\order$\myth-order SCA security can be straightforwardly deduced from the proof given by Ben-Or \etal in \cite{BGW88} in the secure multi-party computation context. Eventually, for $\nbShares=2\order+1$ (which is the parameter choice which optimizes the security/efficiency overhead), the complexity of Algorithm \ref{alg:secmult} in terms of additions and multiplications is ${\cal O}(\order^3)$.
\subsubsection{Our Contribution.}
 \todo{}
\subsubsection{Paper Outline.}


\section{Exact Repair Problem}
\subsection{Preliminaries}

A {\em linear code} $\mathcal{C}$ of length $\nbShares$ and dimension $k$ over a finite field $\Field$ is a $k$-dimensional subspace of $\Field^{\nbShares}$. It is denoted by $\mathcal{C}[n,k]$. A particular linear code is the {\em Reed-Solomon Code} whose definition is recalled hereafter.

\begin{definition}[Reed-Solomon Code]
The Reed-Solomon code $\RS[\pubSet, \order + 1]\subseteq \Field^{\nbShares}$ of dimension $\order + 1$ over a finite field $\Field$ and with evaluation subset $\pubSet = \{\pubElt[1],\pubElt[2],\cdots,\pubElt[\nbShares]\}$ of $\Field$ is the subspace:
$$\RS[\pubSet,\order + 1] = \{(P(\pubElt[1]),P(\pubElt[2]),\cdots,P(\pubElt[\nbShares])); P(X) \in \Field[X] \text{ and } \deg(P) \leqslant \order\} \enspace .$$
\end{definition}

Reed-Solomon codes are {\em Maximum Distance Separable} (MDS) codes, which means that any $\order + 1$ symbols (that is, evaluations of a polynomial $P(X)\in \RS[\pubSet,\order+1]$) can be used to recover the entire codeword (that is,
$P(X)$ itself).
\vspace{3mm}

Let us assume that a file, consisting of $\order + 1$ blocks, is encoded into $\nbShares$ nodes. {\em Exact Repairing codes} have been originally introduced to recover the contents of an erased node by downloading some information from the remaining nodes. In the language of an $\RS[\pubSet,\order+1]$ code as above, the file is a polynomial $P(X)\in \Field[X]$ with $\deg(P(X)) \leqslant \order$ and each node is associated with an evaluation point $\pubElt \in \pubSet$ and stores $P(\pubElt)$. For an arbitrary $\pubEltStar\in \pubSet$ (corresponding to an erased node), the goal is to recover $P(\pubEltStar)$ given some information from the other nodes. Since the code is MDS, its is straightforward to do it by choosing any subset of $\pubSet$ with cardinality $\order + 1$ and by asking the evaluations $P(\pubElt)$ to the corresponding nodes. This means that, for any $\pubEltStar$, the evaluation $P(\pubEltStar)$ can at least be recovered by asking $\log_2(\Field)$ bits of information (corresponding to $P(\pubElt)$) to $\order +1$ nodes. Linear repairing codes aim to define a repairing scheme such that, for any $\pubEltStar$, the evaluation $P(\pubEltStar)$ can be recovered with strictly less than $(\order + 1)\times \log_2(\Field)$ bits of information, by allowing each node to return any $\FField$-linear function of its content, with $\FField$ being a subfield of $\Field$. The $\FField$-linear functions from $\FField$ to $\Field$ may all be defined from the so-called {\em field trace} of $\Field$ over $\FField$. We recall the definition of the field trace hereafter:

\begin{definition}[Field Trace]
Let $p$ and $r$ be two integers and let $q=p^r$. Let $\Field=\GF(q^t)$ be a degree-$t$ finite field extension of a $\FField=\GF(q)$. The {\em field trace} $\myTrace$ is defined for every $\beta \in \Field$ as:
\begin{equation}\label{equ:trace}
\myTrace(\beta) = \beta + \beta^q + \beta^{q^2} + \cdots + \beta^{q^{t-1}} \enspace .
\end{equation}
\end{definition}

In a linear repair scheme, the node corresponding to a public point $\pubElt$ returns zero or more elements of $\FField$ of the form $\myTrace(\gamma P(\pubElt))$ for some field elements $\gamma \in \Field$. A linear exact repair scheme can then be described by the field elements $\gamma$ used by all the nodes, along with a (linear) repair algorithm. A precise definition in the context of Reed-Solomon codes is given below:

\begin{definition}[Linear Exact Repair Scheme (LERS)]\label{def:LERS}
Let $\pubSet = \{\pubElt[1],\pubElt[2],\cdots,\pubElt[\nbShares]\}$ be an evaluation subset of a finite field $\Field$ and let $\RS[\pubSet, \order + 1]\subseteq \Field^{\nbShares}$ be the corresponding Reed-Solomon code. A {\em linear exact repair scheme} for this code over a subfield $\FField$ of $\Field$ is composed of the following steps:
\begin{itemize}
\item for each $\pubEltStar\in \pubSet$, and for each $\pubEltNoIndex\in \pubSet \slash \{\pubEltStar\}$, a set of queries $Q_{\pubEltNoIndex}(\pubEltStar)\subseteq \Field$,
\item for each $\pubEltNoIndex \in \pubSet$ and any polynomial $P(X)\in \Field[X]$ with degree lower than $\order +1$, a linear reconstruction algorithm that computes 
$$
P(\pubEltStar) = \sum_{i=1}^t\lambda_i \cdot \nu_i \enspace ,
$$
for coefficients $\lambda_i\in \FField$ and a basis $\{\nu_1,\nu_2,\cdots,\nu_t\}$ for $\Field$ over $\FField$, so that the coefficients $\lambda_i$ are $\FField$-linear combinations of the queries in 
$$
\bigcup_{\pubEltNoIndex \in \pubSet \slash \{\pubEltStar\}}\{\myTrace(\gamma\cdot P(\pubEltNoIndex); \gamma \in Q_{\pubEltNoIndex}(\pubEltStar)\} \enspace .
$$
\end{itemize}
\end{definition}

The {\em repair bandwith} $RB$ of a LERS is the maximum number of sub-symbols which must be returned by the nodes to recover $P(\pubEltStar)$. It is defined by:
$$
RB = \max_{\pubEltStar \in \pubSet} \sum_{\pubEltNoIndex \in \pubSet \slash \{\pubEltStar\}} \# Q_{\pubEltNoIndex}(\pubEltStar) \enspace .
$$

One of the main goals of LERS schemes is to minimize the maximum number of bits $RB\times \log_2(\FField)$ required to reconstruct $P(\pubEltStar)$ for any $\pubEltStar\in \pubSet$ and any polynomial $P(X)$. During the last few years, there have been several publications tackling this issue in the context of RS codes (see \eg \cite{DRWS11,SPDC13}), or more generally, for MDS codes (see \eg \cite{CHJL11,DGWWR10,SR10}). Depending on the extension dimension $t$ of $\Field$ over $\FField$, some lower bounds have been given:
\begin{itemize}
\item when $t$ is sufficiently large, $RB$ is bounded below by $(t\cdot RL)/(RL-\order)$, where $RL$ denotes the {\em repair locality} and corresponds to the maximum number of $\pubElt \in \pubSet$ that are required to recover $P(\pubEltStar)$ whatever $\pubEltStar \in \pubSet$. For very large values of $t$, several schemes have been proposed for which the lower bound is achieved (see \eg \cite{CHJL11,SR10}).
\item when $t$ is small, it is clear that the lower bound above cannot be achieved since we have $RB \geqslant \order + t$. It must however be observed that this latter bound is much better than the naive one $t\times (\order + 1)$. \comEP{To continue...}
\end{itemize}
\subsection{Explicit Constructions for Reed-Solomon Codes}
In the recent work \cite{GW16}, the authors show that the construction of a LERS for a Reed-Solomon code $\RS[\pubSet, \order + 1]$ and a subfield $\FField$ of $\Field$
is equivalent to the finding, for any $\pubEltStar\in \pubSet$, of field elements $(\zeta_j)_{j\leqslant t}$ and $(\mu_{\pubEltNoIndex,\zeta_j}(\pubEltStar))_{j\leqslant t,,\pubEltNoIndex \in \pubSet}$, such that:
\begin{itemize}
\item (1) for any $j\in [1:t]$, we have 
\begin{equation}\label{equ:LERS_1}
\myTrace(\zeta_j P(\pubEltStar)) = \sum_{\pubEltNoIndex \in \pubSet \slash \{\pubEltStar\}} \myTrace(\mu_{\pubEltNoIndex,\zeta_j}(\pubEltStar)P(\pubEltNoIndex))
\end{equation}
\item and (2) the following equality holds
\begin{equation}\label{equ:LERS_2}
P(\pubEltStar) = \sum_{j=1}^t \myTrace(\zeta_j P(\pubEltStar)) \enspace .
\end{equation}
\end{itemize}
The core observation in \cite{GW16} is that, surprisingly, for some $\pubEltNoIndex\in \pubSet$ the size of all the elements required to build the set $\{\myTrace(\zeta_j P(\pubEltNoIndex));j\in [1;t]\}$ may be smaller than $P(\pubEltNoIndex)$. This implies that the total number of bits required to recover $P(\pubEltStar)$ from \eqref{equ:LERS_1} and \eqref{equ:LERS_2} may be smaller than $(\order +1)\log_2(\# \Field)$ (corresponding to a direct polynomial interpolation). Actually, it is shown in \cite{GW16} that the construction of field elements $(\zeta_j)_{j\leqslant t}$ and $(\mu_{\pubEltNoIndex,\zeta_j}(\pubEltStar))_{j\leqslant t,,\pubEltNoIndex \in \pubSet}$ minimizing the repair bandwidth is equivalent to the problem of finding some nice polynomials over $\Field$ \cite[Theorem 4]{GW16} and some explicit constructions are proposed. In the specific case of Reed-Solomon codes $\RS[\pubSet, \order + 1]$, the construction of the coefficients $(\zeta_j)_{j\leqslant t}$ and $(\mu_{\pubEltNoIndex,\zeta_j}(\pubEltStar))_{j\leqslant t,,\pubEltNoIndex \in \pubSet}$ leading to some repair bandwidth $RB$ over a subfield $\FField\subseteq \Field$ such that $t=[\Field:\FField]$ can be directly deduced from a set $\polySet\in \Field[X]$ of $t$ polynomials of degree $\nbShares - \order - 1$ so that:
$$
\dim_{\FField} (\{p(\pubEltStar): p\in \polySet\}) = t
$$
and the sets $\{p(\pubEltNoIndex): p\in \polySet\}$ for $\pubEltNoIndex \neq \pubEltStar$ satisfy:
$$
RB \geqslant \sum_{\pubEltNoIndex \in \pubSet \backslash \{\pubEltStar\}} \dim_{\FField} (\{p(\pubEltNoIndex): p\in \polySet\}) \enspace .
$$
Once such a family of polynomials $\polySet$ is found the coefficients are built so that
$$
\{\zeta_1,\cdots,\zeta_t\} = \{p(\pubEltStar): p\in \polySet\}
$$
and for every $j\in [1:t]$ and $\pubEltNoIndex \in \pubSet \backslash \{\pubEltStar\}$;
$$
\mu_{\pubEltNoIndex,\zeta_j}(\pubEltStar) = p(\pubEltNoIndex)\times \frac{\prod_{\beta\in \pubSet \backslash \{\pubEltStar\}}(\pubEltStar - \beta)}{\prod_{\beta\in \pubSet \backslash \{\pubEltStar\}}(\pubEltNoIndex - \beta)} \enspace .
$$

 
\subsection{Example}
 \todo{}

\section{Side-Channel analysis of Shamir's Secret Sharing Scheme}
\subsection{Higher-order Side-Channel Resistance: Requirements and Limitations}
\subsubsection{Higher-order Side-Channel Resistance: Requirements.} To design a $\order$\myth-order masking scheme based on Shamir's Secret Sharing for a block cipher, one have to develop some procedures to protect the different operations involved in this protected algorithm. For instance, most of (if not all) linear operations (\emph{e.g.} XOR) are compatible with linear secret sharing. However, nonlinear operations (\emph{e.g.} AES SBox) are more difficult to deal with since it require to protect the multiplication of shares. Some solutions have been developed in the context of protecting the AES using the Shamir's Secret Sharing\cite{GM11,PR11,RP12} and are mainly based on the multiplication scheme introduced by
Ben-Or \etal to design secure multy-party computation schemes\cite{BGW88}.
The method is described in \ref{alg:secmult} and consists in multiplying each two share vectors share by share. This operation corresponds to the multiplication of two degree $d$ polynomials which gives a polynomial of degree $2d$. The secret result of the multiplication can then be recovered with at least $2d + 1$ shares if $n > 2t + 1$. 
So, to achieve a $\order$\myth-order resistance against side-channel attack, the sharing order must be at least $n = 2d + 1$ (\emph{i.e.} the smallest value allowed in Ben-Or \etal multiplication protocol to guarantee $d$\myth-order resistance).

\subsubsection{Higher-order Side-Channel Resistance: Limitations.} On the other hand, a Shamir's secret sharing scheme is said to be secure at the $d$\myth-order if any set of at most $d$ shares reveals no information about the shared secret value. 

\begin{remark}
From an attacker perspective, given an $(n=2d+1,d)$ secret sharing it is theoretically possible to recover the shared secret value by exploiting the leakage of any $(d+1)$ combination of shares over the $d+1 \choose n=2d+1$ possible ones. 
\label{rmk:sca}
\end{remark}
\subsubsection{Higher-order Side-Channel Attack Effectiveness: Discussions.} 
Based on Remark~\ref{rmk:sca}, the following questions would be investigated:
\begin{enumerate}
\item \emph{did all $(d+1)$ combination of shares achieve the same attack efficiency?} Actually, an attacker is spoilt for the choice of the combination of $d+1$ shares to use among the several available ones. Our goal here is to check if all $d+1$ combination of shares leak the same amount of information under the same fixed noise level for each share. The result of this investigation may brings some insights on the optimal $(d+1)$ combination of shares, if any exits, that an attacker should consider when performing his attack.

\item \emph{Did any $(d+2)$ combination of shares achieves a better attack result than all $(d+1)$ combination of shares?}. This question is motivated by the fact that when exploiting the leakage of $(d+2)$ combination of shares, the attacker have theoretically access to exactly the same amount of information leaked by any $(d+1)$ combination of shares. Our purpose here is to check the effectiveness of this claim. If the use of some $(d+2)$ combination of shares are more optimal than some (or all) $(d+1)$ combination of shares in terms of side-channel attack efficiency to recover the  secret value, then one can conclude that the shares are not leaking the same amount of information.
\end{enumerate}    

In what follows, we try to answer these questions by performing practical attacks on simulated traces and real acquisitions captured on the ChipWhisperer platform~\cite{Oâ€™Flynn2014}.

\subsection{Attack results on Simulated Traces}
\subsubsection{Target Implementation.}
For our simulation, we targeted a $(5,2)$ secret sharing scheme, \emph{i.e.} the secret value $Z \in GF(2^8)$ is split into $5$ independent shares $(S_0, \cdots, S_4)$ by evaluating a random polynomial of degree $2$ ($P_Z(X)= Z + \mu_1 X + \mu_2 X^2$) in $5$ public points $(\alpha_0, \cdots, \alpha_4)$ and where $\mu_1$ and $\mu_2$ are two random values in $GF(2^8)$.    

\subsubsection{Leakage Model.}
During the execution of the algorithm, the processing of each share $S_i$ produces some leakage $L_i$ revealing some information about the share value. In our simulation, we have make the following assumptions:
\begin{itemize}
\item given the values of the shares, the leakage has a Gaussian distribution. This assumption is fairly realistic and commonly used in side-channel context~\cite{LPRRT14}, and formally stated by: 
\begin{equation*}
(L_i | S_i = s) \sim \mathcal{N} (m_{i,s}, \Sigma_{j,s}) \enspace,
\end{equation*}
for every share $i$ and for every $s \in GF(2^8)$, where $m_{i,s}$ are expectation vectors defined over $\mathbb{R}^T$ and $\Sigma_{j,s}$ are covariance matrices defined over $\mathbb{R}^{T \times T}$ with $T$ is the dimension of the leakage for each share and is set at $T=1$ in our simulation setup\footnote{If the dimension $T$ equals $1$, then the Gaussian distribution is said to be univariate and its covariance matrix is reduced to the variance of the single coordinate denoted $\sigma^2$. If the $T$ is greater
than $1$, the Gaussian distribution is said to be multivariate.}.
\item The leakage $L_i$ is the sum of two \textit{mutually independent} parts: a deterministic function $f_i$ of the share $S_i$ and a Gaussian noise $N_i$:
\begin{equation*}
L_i = f_i(S_i) +  N_i \enspace.
\end{equation*}
To generate our traces, we considered two types of functions: the Hamming weight and the identity. 
\item The noises $N_i$ are mutually independent and have the same fixed variance ($\sigma^2$). The rational behind this assumption is to have the same noise level for each share. 
\end{itemize}

\subsubsection{Attack Strategy.} To evaluate the $(5,2)$ secret sharing, we have performed a higher-order template attack following the procedure described in~\cite{LPRRT14}. Let $(\boldsymbol{\ell_i})_{1\le i \le N} \in \mathbb{R}^5$ be the set of collected traces for the attack phase, then for any key hypothesis value $k\in GF(2^8)$, the likelihood distinguisher\footnote{In practice, one often makes use of the equivalent (averaged) log-likelihood distinguisher.} is defined as:

\begin{equation*}
d_k= \prod\limits_{i=1}^{N} p_{k}(\boldsymbol{\ell_i}) \enspace,
\end{equation*}    
 
where $p_k$ denotes the probability density function (pdf) of the leakage. Under the Gaussian assumption, the pdf satisfies:   

\begin{equation}
p_s : (\boldsymbol{\ell_i}) = (\boldsymbol{\ell_{0,i}}, \cdots, \boldsymbol{\ell_{4,i}}) \mapsto \frac{1}{256^5} \sum_{s_1 \in GF(2^8)} \cdots \sum_{s_4 \in GF(2^8)} \prod\limits_{j=0}^{4} \phi_{m_{j,s_j}, \sigma^2} (\boldsymbol{\ell_{j,i}})
\label{eq_pdf}
\end{equation} 
 
where, for every value $x \in \mathbb{R}$, the function $\phi_{m,\sigma^2}(x)$ denotes the pdf of a Gaussian distribution with a mean equals to $m$ and a variance equals to $\sigma^2$. 

In~\cite{LPRRT14} authors have demonstrated that for a $d$\myth-order Boolean masking \eqref{eq_pdf} can be expressed as a higher-order convolution product and then they have provided an efficient method to evaluate this formula in $ \mathcal{O}(d \cdot |GF(2^8)| \cdot log|GF(2^8)|)$ operations. 
We recall that:
\begin{itemize}
\item  when a $d$\myth-order Boolean masking is applied, we have $s_0= Z \oplus \bigoplus\limits_{i=1}^{d} (s_i)$ where the $(s_i)_{1 \le i \le d}$ here denotes the random masks.

\item When a $(n,d)$ secret sharing is applied, the sensitive variable $Z$ stratifies: 
\begin{equation}
Z=\bigoplus\limits_{i=0}^{d} (s_i \cdot \beta_i) \enspace,
\label{eq_Z}
\end{equation}
 where $s_i =P_Z(\alpha_i)$ and $\beta_i=\prod\limits_{k=0,k\neq i}^{d} \frac{\alpha_k}{\alpha_i+\alpha_k}$. 
\end{itemize}

To continue using the efficient procedure for higher-order pdf estimation proposed in~\cite{LPRRT14} in the context of secret sharing scheme, we propose hereafter a simple trick. In fact, we can rewrite \eqref{eq_Z} as $s_0=\frac{Z}{\beta_0}\oplus\bigoplus\limits_{i=1}^{d} (s_i \cdot \frac{\beta_i}{\beta_0})$ and then by denoting $Z'=\frac{Z}{\beta_0}$ and $s'=s_i \cdot \frac{\beta_i}{\beta_0}$ for every $i \in [ 1: d$ we obtain:

\begin{equation*}
s_0= Z' \oplus \bigoplus\limits_{i=1}^{d} (s'_i) \enspace.
\end{equation*}

So to evaluate the $(5,2)$ secret sharing scheme, our methodology consists of two-steps:

\begin{enumerate}
\item Profile the leakage of every share using standard estimation techniques. Under the Gaussian leakage assumption, this estimation amounts to compute the sample means ($m_{i,s_i}$) and variance ($\sigma^2$) of the leakage $(L_i | S_i = s)$ for every share $S_i$ and every possible value $s_i$ based on a set of collected leakage samples.
\item Use \label{eq_pdf} to perform the higher-order template attack on a new set of collected traces generated with an unknown secret value $Z$.
\end{enumerate} 

\subsubsection{Attack Results.} 

We plot in Fig.~\ref{fig_3_shares}, for each possible combination of $3$ shares the evolution of the number of traces required to achieve $100\%$ of success rate according to an increasing noise standard deviation. We stress the fact that for each value of the standard deviation, the attacks have been repeated $1.000$ times.  

\begin{figure}
\begin{center}
\includegraphics[width=1\textwidth]{Figure/res_125_246_119_104_150.png}
\caption{Evolution of the number of queries to achieve $100\%$ of success rate according to an increasing noise standard deviation.}
\label{fig_3_shares}
\end{center}
\end{figure}

From Fig.~\ref{fig_3_shares}, we observe that some combinations of $3$-shares perform worst than others despite the fact that all shares have the same level of noise. This result could be explained by the fact that the amount of information is different for each share. Hence, an attacker have to choose the optimal combination of $3$ shares to succeed his attack with less traces. Indeed, we have observed that when we use another set of public points the attack results are different and the optimal combinations of $3$-shares change too as shown in Fig.~\ref{fig_3_shares_bis}.    

\begin{figure}
\begin{center}
\includegraphics[width=1\textwidth]{Figure/res_86_23_115_107_189.png}
\caption{Evolution of the number of queries to achieve $100\%$ of success rate according to an increasing noise standard deviation.}
\label{fig_3_shares_bis}
\end{center}
\end{figure}

Based on these results, we answer the question (did all $(d+1)$ combination of shares achieve the same attack efficiency?) negatively.

The second investigation we planned to perform is to check if exploiting the leakage of $4$ shares could be more efficient than some or all combination of $3$ shares. We show in Fig.~\ref{fig_4_shares} a comparison between the template attack results when considering all combination of $3$ and $4$ shares. The experiences are repeated $1.000$ times for each combination of shares.

\begin{figure}
\begin{center}
\includegraphics[width=1\textwidth]{Figure/5_237_zoom.png}
\caption{Evolution of the number of queries to achieve $100\%$ of success rate according to an increasing noise standard deviation.}
\label{fig_4_shares}
\end{center}
\end{figure}

From Fig.~\ref{fig_4_shares}, one can identify that for a specific interval of noise standard deviation, some combination of $4$ outperform all or some combination of $3$ shares. The same observation is valid when changing the set of public points as described in Fig.~\ref{fig_4_shares_bis}.

\begin{figure}
\begin{center}
\includegraphics[width=1\textwidth]{Figure/169_63_zoom.png}
\caption{Evolution of the number of queries to achieve $100\%$ of success rate according to an increasing noise standard deviation.}
\label{fig_4_shares_bis}
\end{center}
\end{figure}

From Fig.~\ref{fig_4_shares} and Fig.~\ref{fig_4_shares_bis}, the following observations could be emphasized:

\begin{itemize}
\item The shares are not leaking the same amount of leakage despite the fact that the same quantity of noise has been added to the $5$ used shares to protect the sensitive value $Z$. one can easily notice the differences in terms of attack efficiency when comparing the different used combinations of $4$ and $3$ shares.
\item Exploiting the leakage of $4$ shares is more efficient than all combination of $3$ shares for some values of the noise standard deviation. This result could be explained by the fact that the combination of $4$ shares may exploit less amount of information from the leaking shares (than all combination of $3$ shares) to recover efficiently (and fast) the secret value (\emph{i.e.} with less traces). When the noise increases, the efficiency of the template attacks exploiting $4$ shares decreases with respect to these using combination of $3$ shares. This behavior is expected since the more noisy shares you combine, the less the signal-to-noise-ration is. 
\item When comparing both Fig.~\ref{fig_4_shares} and Fig.~\ref{fig_4_shares_bis}, one can notice that the optimal combination of $4$ shares to recover the secret value changes with respect to the used public points. So, the amount of information leaked by the shares depend on the set of public points used to share the secret value. Therefore, an attacker has to adapt the choice of shares to use for his attack with respect to the used set of public points.
\end{itemize}

Based on these observations, we answer the question (Did any $(d+2)$ combination of shares achieves a better attack result than all $(d+1)$ combination of shares?) positively. 

In order to confirm our findings on simulated traces, we conducted some practical attacks on the ChipWhisperer platform. The experimental setup is described in what follows. 

\subsection{Attack results on Real Device}

First, we have implemented a $(5,2)$ secret sharing on an $8$-bit AVR microprocessor atxmega128d3 and we acquired power-consumption traces thanks to the ChipWhisperer-Lite (CW1173) basic board. For the leakage profiling step, we have collected $128.000$ traces to estimate the mean and the variance for each share. These statistical estimation results have shown that the shares have roughly the same variance (\emph{i.e.} the same level of noise) which is in-line with our simulation setup. However, the standard deviation of the noise of the acquired traces is actually outside the suitable area where the combinations of $4$ shares outperform the combination of $3$ shares. The estimated noise standard deviation is about $0.7$.
Then, we have acquired $15.000$ traces for the attack phase and we have performed the template attack by exploiting the leakage of all combination of $4$ and $3$ shares. As expected, the attack results have demonstrated that any combinations of $4$ shares is efficient with respect to the measures noise standard deviation. To decrease the noise level and to fit the suitable interval, we filtered the acquired traces to reach a noise standard deviation value equal to $0.5$. Finally, we re-performed our higher-order template attack. The success rate of the attack for each combination of share is shown in Fig.~\ref{fig_4_shares}.    

\begin{figure}
\begin{center}
\includegraphics[width=1\textwidth]{Figure/SR.png}
\caption{Success rate of the template attack according to an increasing number of traces.}
\label{fig_SR}
\end{center}
\end{figure}

From Fig.~\ref{fig_SR}, one can see that exploiting the leakage of the shares $(0, 1, 3, 4)$ is more suitable in terms of attack efficiency since we require less power measurements to achieve $90\%$ of success rate compared to all combination of $3$ shares. 



\section{Improvement Proposal of Shamir's Secret Sharing Scheme}
 \todo{}


\section{Conclusion}
\label{sec-conc}
 \todo{}
 
\bibliographystyle{abbrv}
\bibliography{sca,ANSSI}

\end{document}
